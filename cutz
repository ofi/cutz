#!/usr/bin/ruby -w

opts = Struct.new(:delimiter, :outputDelimiter, :outputFormat,
                  :thead, :theadAttributes,
                  :tbody, :tbodyAttributes,
                  :tfoot, :tfootAttributes,
                  :elements,
                  :fieldsUsed ).new

CSV=1
TEXT=2
HTML=3

### start-configuration-part ###
opts.delimiter = ' '
opts.elements = Array.new
opts.outputFormat = CSV
opts.fieldsUsed = true
### end-configuration-part ###

require 'optparse'

Field=1
Char=2

Program = $0[/[^\/]*$/]
Author = 'Michael Arlt'
Version = '0.1'

def range2startEnd(range)
  if range =~ /^-?[1-9]+[0-9]*$/
    start=range.to_i
    stop=start
  elsif range =~ /^[1-9]+[0-9]*\-\-$/
    start=range.split('-').to_i
    stop=-1
  elsif range =~ /^-?[1-9]+[0-9]*\.\.(-?[1-9]+[0-9]*|)$/
    start,stop=range.split(/\.\./).map(&:to_i)
    stop=-1 if stop.nil?
  else
    exitHelpError("LIST #{range} is invalid")
  end
  start=start-1 if start > 0
  stop=stop-1 if stop > 0
  return start,stop
end

def range2startLength(range)
  start,stop=range2startEnd(range)
  return start,stop-start+1
end

ARGV.options do |o|
  o.separator ""
  o.banner = "Syntax: #{Program} [options] [file ...]"
  o.separator "    'cutz' cuts similar to cut"
  o.separator "      - default input is stdin"
  o.separator "      - output is stdout"
  o.separator "      - default output format is csv"
  o.separator "      - optional output variants:"
  o.separator "        - html (table records with optional thead, tbody and tfoot)"
  o.separator "        - text (aligned; special ansi if used with thead and tfoot)"
  o.separator "      - LIST format is selection[,selection,...] where selection is:"
  o.separator "          n    # exact n"
  o.separator "          -n   # -1 is the last, -2 is next to last, ..."
  o.separator "          n..m # n upto m - both can be negative"
  o.separator "          n..  # n to end - n can be negative"
  o.separator "      - field and character selection can be combined"
  o.separator "      - character selections separated with ',' differ from ranges with '..'"
  o.separator ""
  o.separator "Examples:"
  o.separator ""
  o.separator "    cutz -d: -f1 -h --tbody id=abc /etc/passwd # login - html"
  o.separator "    df -h | cutz -f3..4,6.. -t --thead # used free mount - colored text table"
  o.separator "    df | tail -n +2 | cutz -f-2.. -o';' # use;mountpoint - csv"
  o.separator "    cutz -f1,-2 -d: -h --tbody -- /etc/passwd # login home - html"
  o.separator "    cutz -d';' -f-1..1 test.csv # reverse csv file"
  o.separator ""
  o.separator "Options:"
  o.separator ""

  o.on( '-d', '--delimiter DELIM', 'Use DELIM instead of whitespace' ) do |d|
    opts.delimiter = d
  end

  o.on( '-o', '--output-delimiter STRING', 'Use DELIM instead of input delimiter' ) do |d|
    opts.outputDelimiter = d
  end

  o.on( '-t', '--text', 'Output simple text table (data in memory!)' ) do
    opts.outputFormat = TEXT
  end

  o.on( '-h', '--html', 'Output simple html table records <tr>...' ) do
    opts.outputFormat = HTML
  end

  o.on( '--thead [html-attributes]', 'Add <thead>(1st line),<tbody> tags to html' ) do |p|
    opts.thead = true
    opts.theadAttributes = p
  end

  o.on( '--tbody [html-attributes]', 'Add <tbody> tags to html output' ) do |p|
    opts.tbody = true
    opts.tbodyAttributes = p
  end

  o.on( '--tfoot [html-attributes]', 'Add <tfoot>(last line),<tbody> tags to html' ) do |p|
    opts.tfoot = true
    opts.tfootAttributes = p
  end

  o.on( '-f', '--fields LIST', 'Select fields' ) do |fieldList|
    fieldList.split(',').each { |element|
      opts.elements << [Field,*range2startEnd(element)]
      opts.fieldsUsed = true
    }
  end

  o.on( '-c', '--characters LIST', 'Select characters' ) do |charList|
    charList.split(',').each { |element|
      opts.elements << [Char,*range2startLength(element)]
    }
  end

  o.on( '-?', '--help', 'Help' ) do
    puts o
    exit
  end

  o.on_tail('-v', '--version', 'Show program version and license information') do
    puts o.ver
    puts "Author #{Author}"
    puts "Use ruby >= 1.9.1 for utf8-aware char cutting"
    puts "This is free software.  You may redistribute copies of it under the terms of"
    puts "the GNU General Public License <http://www.gnu.org/licenses/gpl.html>."
    puts "There is NO WARRANTY, to the extent permitted by law."
    puts "License: GPLv3 - see http://www.gnu.org/licenses/gpl.html"
    exit
  end
end

def exitError(message)
  STDERR.puts "E: #{message}"
  exit 1
end
def exitHelpError(message)
  puts ARGV.options.to_s
  exitError(message)
end
	
begin
  ARGV.parse!
rescue => optparse
  exitHelpError(optparse.message)
end

opts.outputDelimiter = opts.delimiter if opts.outputDelimiter.nil?

class Grid
  def initialize(mode,outputDelimiter,
                 thead,theadAttributes,
                 tbody,tbodyAttributes,
                 tfoot,tfootAttributes)
    @lines=Array.new
    @cols=Array.new
    @maxWidth=Array.new
    @mode=mode
    @outputDelimiter=outputDelimiter
    @thead=@theadend=@tbody=@tbodyend=@tfoot=@tfootend=nil
    if @mode == TEXT
      if thead
        @thead="\033[1m"
        @theadend="\033[0m"
      end
      if tfoot
        @tfoot="\033[2m"
        @tfootend="\033[0m"
      end
    elsif @mode == HTML
      if thead
        @thead="<thead>"
        @theadend="</thead>"
        @thead.insert(-2,' '+theadAttributes) if theadAttributes
      end
      if tbody || thead || tfoot
        @tbody="<tbody>"
        @tbodyend="</tbody>"
        @tbody.insert(-2,' '+tbodyAttributes) if tbodyAttributes
      end
      if tfoot
        @tfoot="<tfoot>"
        @tfootend="</tfoot>"
        @tfoot.insert(-2,' '+tfootAttributes) if tfootAttributes
      end
    end
  end
  def addField(data)
    @cols<<data
    if @mode == TEXT
      if @maxWidth[@cols.length-1].nil? || data.length > @maxWidth[@cols.length-1]
        @maxWidth[@cols.length-1]=data.length
      end
    end
  end
  def lf
    if @mode == TEXT
      @lines<<@cols.clone
    elsif @mode == CSV
      puts @cols.join(@outputDelimiter)
    else
      if @thead
        puts @thead if @thead
        puts '<tr><th>' + @cols.join('</th><th>') + '</th></tr>'
        puts @theadend if @thead
        @thead=@theadend=nil
      else
        if @tbody
          puts @tbody if @tbody
          @tbody=nil
        end
        puts '<tr><td>' + @cols.join('</td><td>') + '</td></tr>'
      end
    end
    @cols.clear
  end
  def finish
    if @mode == TEXT
      self.lf
      i=0
      while i < @lines.length
        line=@lines[i]
        print @tfoot if @tfoot && i == @lines.length - 1 && @lines.length > 2
        print @thead if i == 0 && @thead
        j=0
        while j < line.length
          printf "%-#{@maxWidth[j]+1}s",line[j]
          j+=1
        end
        print @theadend if i == 0 && @theadend
        print @tfootend if @tfoot && i == @lines.length - 1
        i+=1
        puts
      end
    elsif @mode == CSV
      self.lf
    elsif @mode == HTML
      if @tbody
        self.lf
        puts @tbodyend if !@tbody
      elsif @tfoot
        puts @tbodyend
        puts @tfoot
        self.lf
        puts @tfootend
      else
        self.lf
        puts @tbodyend if @tbodyend && !@tbody
      end
    end
  end
end

grid = Grid.new(opts.outputFormat,opts.outputDelimiter,
                opts.thead,opts.theadAttributes,
                opts.tbody,opts.tbodyAttributes,
                opts.tfoot,opts.tfootAttributes)

dataReceived = false
while line = gets
  grid.lf if dataReceived
  fields=Array.new
  line.chomp!
  cols=line.split(opts.delimiter) if opts.fieldsUsed
  opts.elements.each { |type,elementStart,elementEnd|
    if type == Field
      elementStart = cols.length + elementStart if elementStart < 0
      elementEnd = cols.length + elementEnd if elementEnd < 0
      step = elementEnd > elementStart ? 1 : -1
      element = elementStart
      loop do
        grid.addField(cols[element]) if cols[element] != nil
        break if element == elementEnd
        element+=step
      end
    elsif type == Char
      grid.addField(line[elementStart,elementEnd]) if line[elementStart,1] != nil
    end
  }
  dataReceived = true
end

grid.finish
